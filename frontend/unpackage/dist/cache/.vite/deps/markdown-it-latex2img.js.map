{
  "version": 3,
  "sources": ["../../../../../node_modules/markdown-it-latex2img/index.js"],
  "sourcesContent": ["// Process latex\n//\n\"use strict\";\n\nfunction isValidDelim(state, pos) {\n  let prevChar,\n    nextChar,\n    max = state.posMax,\n    can_open = true,\n    can_close = true;\n\n  prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n  nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n  // Check non-whitespace conditions for opening and closing, and\n  // check that closing delimeter isn't followed by a number\n  if (\n    prevChar === 0x20 /* \" \" */ ||\n    prevChar === 0x09 /* \\t */ ||\n    (nextChar >= 0x30 /* \"0\" */ && nextChar <= 0x39) /* \"9\" */\n  ) {\n    can_close = false;\n  }\n  if (nextChar === 0x20 /* \" \" */ || nextChar === 0x09 /* \\t */) {\n    can_open = false;\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n  };\n}\n\nfunction math_inline(state, silent) {\n  let start, match, token, res, pos;\n\n  if (state.src[state.pos] !== \"$\") {\n    return false;\n  }\n\n  res = isValidDelim(state, state.pos);\n  if (!res.can_open) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n    state.pos += 1;\n    return true;\n  }\n\n  // First check for and bypass all properly escaped delimieters\n  // This loop will assume that the first leading backtick can not\n  // be the first character in state.src, which is known since\n  // we have found an opening delimieter already.\n  start = state.pos + 1;\n  match = start;\n  while ((match = state.src.indexOf(\"$\", match)) !== -1) {\n    // Found potential $, look for escapes, pos will point to\n    // first non escape when complete\n    pos = match - 1;\n    while (state.src[pos] === \"\\\\\") {\n      pos -= 1;\n    }\n\n    // Even number of escapes, potential closing delimiter found\n    if ((match - pos) % 2 == 1) {\n      break;\n    }\n    match += 1;\n  }\n\n  // No closing delimter found.  Consume $ and continue.\n  if (match === -1) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n    state.pos = start;\n    return true;\n  }\n\n  // Check if we have empty content, ie: $$.  Do not parse.\n  if (match - start === 0) {\n    if (!silent) {\n      state.pending += \"$$\";\n    }\n    state.pos = start + 1;\n    return true;\n  }\n\n  // Check for valid closing delimiter\n  res = isValidDelim(state, match);\n  if (!res.can_close) {\n    if (!silent) {\n      state.pending += \"$\";\n    }\n    state.pos = start;\n    return true;\n  }\n\n  if (!silent) {\n    token = state.push(\"math_inline\", \"math\", 0);\n    token.markup = \"$\";\n    token.content = state.src.slice(start, match);\n  }\n\n  state.pos = match + 1;\n  return true;\n}\n\nfunction math_block(state, start, end, silent) {\n  let firstLine,\n    lastLine,\n    next,\n    lastPos,\n    found = false,\n    token,\n    pos = state.bMarks[start] + state.tShift[start],\n    max = state.eMarks[start];\n\n  if (pos + 2 > max) {\n    return false;\n  }\n  if (state.src.slice(pos, pos + 2) !== \"$$\") {\n    return false;\n  }\n\n  pos += 2;\n  firstLine = state.src.slice(pos, max);\n\n  if (silent) {\n    return true;\n  }\n  if (firstLine.trim().slice(-2) === \"$$\") {\n    // Single line expression\n    firstLine = firstLine.trim().slice(0, -2);\n    found = true;\n  }\n\n  for (next = start; !found;) {\n    next++;\n\n    if (next >= end) {\n      break;\n    }\n\n    pos = state.bMarks[next] + state.tShift[next];\n    max = state.eMarks[next];\n\n    if (pos < max && state.tShift[next] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      break;\n    }\n\n    if (state.src.slice(pos, max).trim().slice(-2) === \"$$\") {\n      lastPos = state.src.slice(0, max).lastIndexOf(\"$$\");\n      lastLine = state.src.slice(pos, lastPos);\n      found = true;\n    }\n  }\n\n  state.line = next + 1;\n\n  token = state.push(\"math_block\", \"math\", 0);\n  token.block = true;\n  token.content =\n    (firstLine && firstLine.trim() ? firstLine + \"\\n\" : \"\") +\n    state.getLines(start + 1, next, state.tShift[start], true) +\n    (lastLine && lastLine.trim() ? lastLine : \"\");\n  token.map = [start, state.line];\n  token.markup = \"$$\";\n  return true;\n}\n\nmodule.exports = (md, options) => {\n  options = options || {};\n  options.server = options.server || \"https://math.now.sh\";\n  options.style = options.style || \"\";\n  const purifiedURL = (latex) => {\n    return encodeURIComponent(latex).replace(\"(\", \"%28\").replace(\")\", \"%29\");\n  };\n\n  let Inline = (latex) => {\n    try {\n      return `<img src=\"${options.server}?inline=${purifiedURL(latex)}\" style=\"${options.style}display:inline-block;margin: 0;\"/>`;\n    } catch (error) {\n      console.error(error);\n      return latex;\n    }\n  };\n\n  let Block = (latex) => {\n    try {\n      return `<p style=\"${options.style}\"><img src=\"${options.server}?from=${purifiedURL(\n        latex\n      )}\" /></p>`;\n    } catch (error) {\n      console.error(error);\n      return latex;\n    }\n  };\n\n  md.inline.ruler.after(\"escape\", \"math_inline\", math_inline);\n  md.block.ruler.after(\"blockquote\", \"math_block\", math_block, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n  md.renderer.rules.math_inline = (tokens, idx) => {\n    return Inline(tokens[idx].content);\n  };\n  md.renderer.rules.math_block = (tokens, idx) => {\n    return Block(tokens[idx].content);\n  };\n};\n"],
  "mappings": "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",
  "names": []
}
